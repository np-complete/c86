# 出撃・戦闘

この章ではゲームの華である戦闘のAPIを解説します。

## 出撃・戦闘の流れ

戦闘に関係するAPIは

- 移動系API
- 戦闘系API
- 結果系API

の3種類に分類できます。
これを繰り返して戦闘します。

### 移動系API

出撃するマップを選んだ時の「出撃API」と、戦闘後に進軍を選んだ時の「進軍API」がなぜか同じレスポンスです。
羅針盤が回っている時には既に行き先は決定しています。

レスポンスには移動先の情報が含まれていますが、本当に知性を感じられない設計になっています。
戦闘に重要な属性は `api_color_no` という意味の分からないキー名が振られています@<fn>{color_no}。
夜戦スタートとかは判明したんですが潜水艦の判定を出してるのがどこなのかは最後まで判明しませんでした。

あと物資がもらえるマスを通っても物資が増えないという現象に遭遇しました。
これも最後まで何をすれば回収できるのか判明しませんでした@<fn>{what-cruising}。

//footnote[color_no][[https://github.com/masarakki/IJN48/blob/master/lib/naka/models/battle/move.rb#L15]()]
//footnote[what-cruising][オリョクル? なにそれ美味しいの?]
### 戦闘系API

移動先の戦闘属性に従って適切な戦闘APIを叩く必要があります。
戦闘APIは「通常戦闘」「夜間戦闘」「夜から昼」の3種類があります。
「通常戦闘からの夜戦」と「夜間戦闘」は別のAPIです。

戦闘APIを叩くと戦闘結果が返ってきます。
信じがたいほど理解しにくいJSON@<fn>{battle-result}で、知性の欠如を感じます。

例えば砲撃の結果は、 `api_hougeki` の中に `api_def_list` と `api_damage` の2つの配列@<fn>{ignore-attacker}が入っています。

```json
{"api_hougeki": {
  "api_def_list": [10, 3, 12, 1, ...],
  "api_damage": [25, 3, 15, -1, ...],
  ...
 }
}
```

このデータを、`api_def_list` の `n` 番目に書かれた艦@<fn>{ship-index}に `api_damage` の `n` 番目に書かれた数字をダメージとして与える、というルールで処理していきます。

`api_hougeki` を配列に、その中の要素をハッシュにしたほうが圧倒的に理解しやすい表現です。

```json
{"api_hougeki": [
  {"attacker":  1, "defender": 10, "damage": 25},
  {"attacker": 11, "defender":  3, "damage":  3},
  {"attacker":  4, "defender": 12, "damage": 15},
  {"attacker": 12, "defender":  1, "damage": -1},
   ...
 ]
}
```

サイズが気になるなら、可読性は落ちますがハッシュではなく配列にしてもいいでしょう。

```json
{"api_hougeki": [
  [ 1, 10, 25],
  [11,  3,  3],
  [ 4, 12, 15],
  [12,  1, -1],
   ...
 ]
}
```

この場合コードによる補足が無いと理解しづらいですが、`api_hougeki` が配列なだけで遥かにマシです。
APIレスポンスは人間の理解できる構造を表現するべきであり、
元のレスポンスは `for` 文 という**コンピュータの処理の都合**に合わせて作られていて不適切です@<fn>{old-for}。

なお、去年の冬くらいに、
「戦闘APIを叩いたあとは10秒間待たないと次のAPIリクエストがことごとくエラーになる」
ように仕様変更されました。
このタイミングでイベント以外のプレイを完全に辞めました。

//footnote[battle-result][[https://github.com/masarakki/IJN48/blob/master/lib/naka/models/battle/battle.rb#L18]()]
//footnote[ignore-attacker][誰が攻撃したかは戦闘結果に関係ないので無視している]
//footnote[ship-index][敵味方艦混合でインデックスが振られる 味方艦:1-6 敵艦:7-12 みたいな感じに]
//footnote[old-for][元レスポンスの配列は固定長 つまり固定回数の `for` を回している可能性がある 圧倒的にダサい]

### 結果系API

結果APIを叩くとそのマスでの戦闘が終了します。
夜戦に行かない場合も結果APIを叩きます。
レスポンスは関心がないので調べてませんが、経験値とかドロップとかが書かれているんだと思います。

マップの終端に到達した場合や進撃せずに撤退する場合は、母港画面に戻り、艦隊情報の取得などの一連APIが叩かれます。
この一連のAPIの中にある `/kcsapi/api_auth_member/logincheck` というAPIが、
実は**出撃状態だったら出撃を完了する**という処理をしています。
まったく名が体を表していないし、ユーザからしたら完全に副作用です。いみわかんない。
出撃中に猫った場合、再ログインさせられてれて母港に飛ぶので出撃状態が解除されます。

## 問題点

戦闘の流れはとにかく理解しにくいです。
完全に場当たり的な実装を繰り返しているのが想像できます。
レスポンスも整理されておらず、違うAPIなのに同じようなレスポンスを返していたりします。
出撃という行動のモデリングができてないと思われます。

### RESTという考え方

RESTでは、物事をリソースとしてURLで表現し、HTTPメソッドを正しく使ってそのリソースを操作します。
RESTとAPIは相性がよく、よい設計の助けになります。

## RESTful戦闘API設計サンプル

出撃-戦闘-結果 の一連のAPIをRESTfulにしてみましょう。
戦闘に限らずゲームはリソース作成/操作の積み重ねです。
全てのリソースを頭から再評価すれば最後の状態を復元できるようにします。

### 出撃

まず1つ目のリソースは**出撃**です。英語だと**sotie**です。
まず出撃するには `POST` メソッドで新しい `sotie` のリソースを作成します。
`map_id` や `fleet_id` などがパラメータになるでしょう。

    POST /soties

レスポンスはこのようになります。

```json
{
  "id": 2341234,
  "fleet_id": 1,
  "area_id": 3,
  "map_id": 2,
  "done": false
}
```

すでに出撃中の場合@<fn>{in-sotie}、APIは `400 Bad Request` を返して失敗します。

//footnote[in-sotie][つまり `done` が `false` な `sotie` が存在する場合]

この**出撃のリソース**には何時でも、何回でもアクセスでき、常に正しい情報が取得できます@<fn>{idempotence}。

    GET /soties/2341234

//footnote[idempotence][このような性質を**冪等性**と言う HTTPの `GET` は冪等性を持つべきとされている]

出撃を終了するには `DELETE` メソッドを使います。

    DELETE /soties/2341234

リクエストを見るだけで `done` が `true` に設定されると想像できるでしょう@<fn>{soft-delete}。

//footnote[soft-delete][この方法を**論理削除**という 記録を残す必要がなければ単に**物理削除**してもよい]

### 移動

移動もリソースと考えて良いと思います。
リソースは**move**です。
リソースは名詞というルールがあるので、動詞のmoveではなく名詞のmoveであることを忘れてはいけません。
`POST` メソッドで移動を作成します。

    POST /soties/2341234/moves

移動できる場合は、移動先の情報と次にすべきことを示したデータが取得できます。

例えば戦闘が必要なマスに移動した場合はこのような感じでしょうか。

```json
{
  "id": 98765,
  "cell": 1,
  "type": "battle",
  "submarine": true,
  "boss": false,
  "next" "battle"
}
```

みんな大好き物資マスはこんな感じですね。

```json
{
  "id": 98766,
  "cell": 2,
  "type": "supply",
  "items": {
    "steel": 15,
    "fuel": 5
  },
  "next": "move"
}
```

移動できない場合@<fn>{cant-move}は、`400 Bad Request` を返します。
レスポンスの中身に戦闘しろ、とか帰還しろ、のように書いてもいいと思います。

//footnote[cant-move][戦闘しないといけない場合や終端の時など]

もちろん作ったリソースは `GET` で何度でも情報は取得できるし、
更に全ての移動経路も取得できるAPIも欲しいですね。

    GET /soties/2341234/moves/98765
    GET /soties/2341234/moves

### 戦闘と結果

戦闘するときも、まず `POST` メソッドで**battle**を作ります。

    POST /soties/2341234/battles

元のAPIだと通常戦闘なのか、夜戦なのか、などによって呼び出すAPIが違いましたが、
戦闘というリソースは一つのはずなので変えません。

```json
{
  "id": 132435,
  "type": "normal"
}
```

とりあえず戦闘のリソースを作りました。
このとりあえずというのが重要です。
サーバは現在の状態を知っているので、`sotie_id` と `cell` が自動で記録されます。
APIレスポンスに載せるかどうかは別の話です。

通常戦闘の場合、陣形を選択します。
これは、作った戦闘のリソースの陣形を変更すると考えます。
存在するリソースへの変更は `PUT` を使います。

    PUT /soties/2341234/battles/132435

    formation=3

これは**何度でも実行できる**べきです。
また、変更できない場合@<fn>{cant-modify-formation}は、`400 Bad Request` を返してもいいし、
`200 Success` を返しつつ変更は無視してもいいでしょう。

//footnote[cant-modify-formation][少数編成の場合や通常戦闘でない場合]

戦闘結果を取得しましょう。

    GET /soties/2341234/battles/132435/result

もちろん `GET` なので**何度叩いても良いし、常に同じ結果**を返します。
具体的には、最初にリクエストされた時に戦闘の計算を行い、戦闘結果を確定し、データベース等に記録します。
艦隊へのダメージや、燃料砲弾の減算の反映なども行います。
内部的に持っている**昼戦確定フラグ**のようなものも立てておきます。
いったん昼戦確定フラグが立ったら、陣形の変更は二度とできないようにしなければなりません。
2度目以降のアクセスは、データベース等に記録された内容を返します。

通常戦闘はこのあと夜戦に行くことができます。
やはりこれも戦闘リソースを変更すると考えます。

    PUT /soties/2341234/battles/132435

    night_battle=true

夜戦した場合の戦闘結果も同様です。

    GET /soties/2341234/battles/132435/result

夜戦結果が無かったら計算を行い、記録し、結果を返します。
戦闘リソースとしては1つなので、昼戦の結果に更に夜戦の結果が追加されたような形になります。
夜戦だけの結果を返すのは間違っています。
もちろん夜戦確定フラグのようなものを立てておきます。
もう `night_battle=false` にすることはできません。

戦闘が終わったら経験値と艦娘ゲットの時間です。
`PUT` で終了を伝えましょう。

    PUT /soties/2341234/battles/132435
    complete=true

その後

    GET /soties/2341234/battles/132435/result

を叩くと、経験値やドロップが追加された戦闘結果が取得できます。

ゲームでは順々に処理されていくので無理ですが、APIではこのようにリクエストすることも可能です。

    PUT /soties/2341234/battles/132435

    formation=3&night_battle=false&complete=true

これでresultを叩けば一発で結果が取得できます。

### 状態の復旧

現在のAPIでは、何かエラーがあるとすぐに**猫画面**を出し、
とにかくリロードさせ、全てを諦めて母港に飛ばします。
この仕様は本物の糞です。

最後にどの状態だったのか、サーバは知っているはずです。
きちんと設計すれば直前の状況まで復旧することは可能です@<fn>{enable-now}。
今回の実装例だと、過去も含めて全ての出撃を再現可能です@<fn>{store-initial-fleet}。

この点パズドラは本当に上手くやっていると思います。

//footnote[enable-now][現状でも可能だと思うんですけどね・・・出撃終了条件を変な扱いしてるから・・・]
//footnote[store-initial-fleet][出撃時の艦隊の状態を保存する必要があります]

### 問題点

たぶんこの戦闘APIの設計には色々反論したい人がいると思います。
夜戦は新しいリソースとして作るべきだとか、それぞれのresult分けるべきだとか、
`POST /battles` の瞬間に結果を確定させるべきだとか、まぁいろいろ思うところはあると思います。
これもただの一例なので、**よく考えて作ろう**とか
**俺はこんなふうに思考して作ってる**って部分が伝わればいいと思います@<fn>{hidden-from-fundamentalism}。

//footnote[hidden-from-fundamentalism][こわいこわいRESTfulおじさんに見つかりませんように・・・]

このAPI設計の問題点として、明らかに**更新の処理が複雑になる**のが目に見えています。
どのパラメータを弄れるかというのがかなり状態に依存するので、
さらに内部を綺麗に設計しないと巨大な`if`文の**闇**になるでしょう。
ただし他の部分に闇がなくなるので、
このような**闇を一箇所に押し込めた設計**は完全な悪では無いと思います。

## まとめ: API改善ガイド

- リクエストとレスポンスを1対1対応させる
- JSONは処理の都合ではなくあるべき構造に合わせる
- リソースの概念を理解しAPIを整理する
- 状態での分岐を減らす

根本的な問題は、度重なる仕様変更でどんどん戦闘システムが複雑になっていることです。
その対応として場当たり的な拡張を続け、はっきり言ってシステムは破綻しています。
艦これが圧倒的につまらない原因はこの複雑な戦闘システムです。

外から見ただけでは分からないのでここでは触れていませんが、
実際の戦闘の処理も相当複雑なコードになっていると思います。
特にイベントボスの弱点に特定の装備を設定しているところなど、
API設計の能力を見る感じではたぶん相当複雑でカオスなコードになっているんじゃないでしょうか。
あと3回くらいイベントをやった後くらいには、
戦闘の処理をする関数を含むファイルは社内で『**聖典**』などと呼ばれるようになると予測します。
そうなるともう手が付けられず、誰も変更の影響範囲を正しく把握できず、
少しの変更でもバグが出て何週間もかかるような状態になります。

まずはとにかくゲームシステムの単純さを取り戻すことが何より重要だと思います。
